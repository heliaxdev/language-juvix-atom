name: 'Juvix'
scopeName: 'source.juvix'
filelets: ['ju']
patterns:
  [
    {
      name: 'keyword.control.juvix'
      match: '\\b(if|then|else|do|let|in|record|end|sig)\\b'
    }
    {
      name: 'keyword.control.juvix'
      match: '\\b(case|of|infix|infixl|infixr)\\b'
    }
    {
      name: 'keyword.control.juvix'
      match: '\\b(where|with|syntax|proof|postulate|using|record|instance|interface|implementation|record|rewrite)\\b'
    }
    {
      name: 'keyword.control.juvix'
      match:  '\\b(public|private|export|implicit)\\b'
    }
    {
      name: 'comment.line.juvix'
      match: '(--).*$\n?'
      comment: 'Line comment'
    }
    {
      name: 'comment.documentation.line.juvix'
      match: '(\\|\\|\\|).*$\n?'
      comment: 'Line comment'
    }
    {
      name: 'storage.let.function.juvix'
      match: '\\?[-!#\\$%&\\*\\+\\.\\/<=>@\\\\\^\|~:]+|[-!#\\$%&\\*\\+\\.\\/<=>@\\\\\^\|~:\\?][-!#\\$%&\\*\\+\\.\\/<=>@\\\\\^\|~:]*'
    }
    {
      name: 'keyword.let.builtin.juvix'
      match: '\\b(let|int|nat|integer|float|char|string|bytes|bool|storage)\\b'
    }
    {
      name: 'constant.numeric.juvix'
      match: '\\b(S|Z)\\b'
    }
    {
      match: '\\b([0-9]+|0([xX][0-9a-fA-F]+|[oO][0-7]+))\\b'
      name: 'constant.numeric.juvix'
      comment: 'integer literal'
    }
    {
      match: '\\b([0-9]+\\.[0-9]+([eE][+-]?[0-9]+)?|[0-9]+[eE][+-]?[0-9]+)\\b'
      name: 'constant.numeric.float.juvix'
      comment: 'float literal'
    }
    {
      match: '\\(\\)'
      name: 'constant.unit.juvix'
    }
    {
      name: 'comment.block.juvix'
      begin: '\\{-'
      end: '-\\}'
      comment: 'Block comment'
    }
    {
      name: 'string.quoted.double.juvix'
      begin: '"'
      beginCaptures:
        0:
          name: 'punctuation.definition.string.begin.juvix'
      end: '"'
      endCaptures:
        0:
          name: 'punctuation.definition.string.end.juvix'
      patterns:
        [
          {
            include: '#escape_characters'
          }
        ]
    }
    {
      name: 'variable.other.juvix'
      match : "(?<!\\w)\\'\\w++(?!')(?!\\-)"
    }
    {
      name: 'string.quoted.single.juvix'
      match: "(')(?:(?:\\\\\")|(?:\\\\[0-9]+)|(\\\\o[0-7]+)|(\\\\x[0-9a-fA-F]+)|(?:[^'])|(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL))(')"
      captures:
        1:
          name: 'punctuation.definition.string.begin.juvix'
        2:
          name: 'constant.character.escape.octal.juvix'
        3:
          name: 'constant.character.escape.hexadecimal.juvix'
        4:
          name: 'constant.character.escape.control.juvix'
        5:
          name: 'punctuation.definition.string.end.juvix'
      patterns:
        [
          {
            name: 'invalid.illegal.juvix'
            match: "\\\\n"
          }
        ]
    }
    {
      name: 'keyword.operator.function.infix.juvix'
      begin: '`(?![\{|\(])'
      beginCaptures:
        0:
          name: 'punctuation.definition.entity.juvix'
      end: '`'
      endCaptures:
        0:
          name: 'punctuation.definition.entity.juvix'
    }
    {
      begin: '\\b(mod)\\b'
      beginCaptures:
        1:
          name: 'keyword.control.juvix'
      end: '($|;|(?=--))'
      name: 'meta.module.juvix'
      patterns:
        [
          {
            match: "([a-zA-Z._\\-']+)"
            name: 'meta.declaration.module.juvix'
          }
        ]
    }
    {
      begin: '\\b(import\\s+public|import)\\b'
      beginCaptures:
        1:
          name: 'keyword.other.juvix'
      end: '($|;|(?=--))'
      name: 'meta.import.juvix'
      patterns:
        [
          {
            match: "([a-zA-Z._\\-']+)"
            name: 'support.other.module.juvix'
          }
        ]
    }
    {
      name: 'meta.declaration.data.juvix'
      begin: "\\b(let)\\s+([\\w']+)\\s*(:)?"
      beginCaptures:
        1:
          name: 'keyword.other.juvix'
        2:
          name: 'entity.name.let.juvix'
        3:
          name: 'keyword.operator.colon.juvix'
      end: '\\b(where)\\b|(=)|$'
      endCaptures:
        1:
          name: 'keyword.other.juvix'
        2:
          name: 'keyword.operator.juvix'
      patterns:
        [
          include: '#let_signature'
        ]
    }
    {
      name: 'meta.declaration.data.juvix'
      begin: "\\b(parameters)\\s+(\\()"
      end: "(\\))$"
      beginCaptures:
        1:
          name: 'keyword.other.juvix'
        2:
          name: 'punctuation.context.begin.juvix'
      endCaptures:
        1:
          name: 'punctuation.context.begin.juvix'
      patterns:
        [
            {
              name: 'comment.line.juvix'
              match: '(--).*$\n?'
            }
            {
              name: 'meta.parameter.block.named.juvix'
              match: "((\\w+)\\s*(:)\\s*(\\w+)\\s*)"
              captures:
                2:
                  name: 'entity.name.tag.juvix'
                3:
                  name: 'keyword.operator.colon.juvix'
            }
        ]
    }
    {
      include: '#function_signature'
    }
    {
      name: 'keyword.operator.juvix'
      match: "[|&!%$?~+:\\-.=</>\\\\*]+"
    }
    {
      include: '#data_ctor'
    }
  ]
repository:
  context_signature:
    patterns:
      [
        {
          name: 'meta.context-signature.juvix'
          match: "([\\w._']+)((\\s+[\\w_']+)+)\\s*(=>)"
          captures:
            1:
              name: 'entity.other.inherited-class.juvix'
            2:
              name: 'entity.other.attribute-name.juvix'
            4:
              name: 'keyword.operator.double-arrow.juvix'
        }
        {
          name: 'meta.context-signature.juvix'
          comment:
            """For things like '(Eq a, Show b) =>'
            It begins with '(' or followed by ') =>' on the same line,
            or anything but ')' until the end of line."""
          begin: "(\\()((?=.*\\)\\s*=>)|(?=[^)]*$))"
          beginCaptures:
            1:
              name: 'punctuation.context.begin.juvix'
          end: "(\\))\\s*(=>)"
          endCaptures:
            1:
              name: 'punctuation.context.end.juvix'
            2:
              name: 'keyword.operator.double-arrow.juvix'
          patterns:
            [
              {
                name: 'meta.class-constraint.juvix'
                match: "([\\w']+)\\s+([\\w']+)"
                captures:
                  1:
                    name: 'entity.other.inherited-class.juvix'
                  2:
                    name: 'entity.other.attribute-name.juvix'
              }
            ]
        }
      ]
  parameter_let:
    comment: "Parameter lets in a let signature"
    patterns:
      [
        {
          include: '#prelude_let'
        }
        {
          name: 'meta.parameter.named.juvix'
          comment: '(x : Nat)'
          begin: "\\(([\\w']+)\\s*:(?!:)"
          beginCaptures:
            1:
              name: 'entity.name.tag.juvix'
          end: "\\)"
          patterns:
            [
              {
                include: '#prelude_let'
              }
            ]
        }
        {
          name: 'meta.parameter.implicit.juvix'
          comment: '{auto p : a = b}'
          begin: "\\{((auto|default .+)\\s+)?([\\w']+)\\s*:(?!:)"
          beginCaptures:
            1:
              name: 'storage.modifier.juvix'
            3:
              name: 'entity.name.tag.juvix'
          end: '\\}'
          patterns:
            [
              {
                include: '#prelude_let'
              }
            ]
        }
      ]
  let_signature:
    patterns:
      [
        {
          name: 'keyword.operator.arrow.juvix'
          match: '->'
        }
        {
          include: '#context_signature'
        }
        {
          include: '#parameter_let'
        }
        {
          include: '#language_const'
        }
      ]
  function_signature:
    name: 'meta.function.let-signature.juvix'
    begin: "(([\\w']+)|\\(([|!%$+\\-.,=</>:]+)\\))\\s*(:)(?!:)"
    beginCaptures:
      2:
        name: 'entity.name.function.juvix'
      3:
        name: 'entity.name.function.juvix'
      4:
        name: 'keyword.operator.colon.juvix'
    end: "(;|(?=--)|(?<=[^\\s>])\\s*(?!->)\\s*$)"
    patterns:
      [
        {
          include: '#let_signature'
        }
      ]
    comment: """The end patterm is a bit tricky. It's or ';' or something, at the end of the line,
      but not '->', because a let signature can be multiline. Though, it doesn't help, if you
      break the signature before arrows."""
  language_const:
    patterns:
      [
        {
          name: 'constant.language.unit.juvix'
          match: "\\(\\)"
        }
        {
          name: 'constant.language.bottom.juvix'
          match: "_\\|_"
        }
        {
          name: 'constant.language.underscore.juvix'
          match: "\\b_\\b"
        }
      ]
  escape_characters:
    patterns:
      [
        {
          name: 'constant.character.escape.ascii.juvix'
          match: '\\\\(NUL|SOH|STX|ETX|EOT|ENQ|ACK|BEL|BS|HT|LF|VT|FF|CR|SO|SI|DLE|DC1|DC2|DC3|DC4|NAK|SYN|ETB|CAN|EM|SUB|ESC|FS|GS|RS|US|SP|DEL|[abfnrtv\\\\\\"\'\\&])'
        }
        {
          name: 'constant.character.escape.octal.juvix'
          match: '\\\\o[0-7]+|\\\\x[0-9A-Fa-f]+|\\\\[0-9]+'
        }
        {
          name: 'constant.character.escape.control.juvix'
          match: '\\^[A-Z@\\[\\]\\\\\\^_]'
        }
      ]
  data_ctor:
    patterns:
      [
        {
          'name': 'entity.name.tag.juvix'
          'match': '\\b[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\']*(?:\\.[\\p{Lu}\\p{Lt}][\\p{Ll}_\\p{Lu}\\p{Lt}\\p{Nd}\'\\-_]*)*\\b'
        }
      ]
